%% Simulation der Bewegung eines Doppelpendels%  Dieses Skript löst die Bewegungsgleichungen eines Doppelpendels numerisch %  für zwei verschiedene Anfangsbedingungen.%{THEORETISCHER HINTERGRUNDDas Doppelpendel besteht aus zwei Pendeln, die aneinander befestigt sind. Die Bewegung wird durch zwei gekoppelte Differentialgleichungen zweiter Ordnung beschrieben.Systemvariablen:  theta1, theta2 : Auslenkwinkel (0 = senkrecht nach unten)  l1, l2         : Länge der Pendelstangen  m1, m2         : Massen der Pendelkörper  g              : ErdbeschleunigungBewegungsgleichungen (Matrix-Form):-----------------------------------Um die Beschleunigungen (theta1_ddot, theta2_ddot) zu berechnen, wird das System in die Matrixform A * x = b gebracht. Dies ist notwendig, um das System numerisch mit ode45 zu lösen.Das Gleichungssystem lautet:    [ 1              k1*cos(delta) ] * [ theta1_ddot ] = [ b1 ]  [ k2*cos(delta)  1             ]   [ theta2_ddot ]   [ b2 ]Wobei:  delta = theta1 - theta2  omega = d(theta)/dt (Winkelgeschwindigkeit)Die Hilfskonstanten sind:  k1 = (m2 / (m1 + m2)) * (l2 / l1)  k2 = l1 / l2Der Vektor b (Rechte Seite) enthält Gravitations- und Zentripetal-Terme:  b1 = -k1 * omega2^2 * sin(delta) - (g / l1) * sin(theta1)  b2 =  k2 * omega1^2 * sin(delta) - (g / l2) * sin(theta2)Lösung im Code:---------------In der Funktion 'pendulum_dynamics' wird nach den Winkelbeschleunigungen aufgelöst:  x = A \ b oder mldivide(A,b)Das System wird dann als Zustandsraummodell erster Ordnung integriert.%}clear; clc; close all;%% 1. Definition der globalen Parameterp.g = 9.81;      % Erdbeschleunigung [m/s^2]p.m1 = 1.0;      % Masse 1 [kg]p.m2 = 1.0;      % Masse 2 [kg]p.l2 = 1.0;      % Länge 2 [m]p.l1 = 2 * p.l2; % Länge 1% Zeitspanne für die Simulationt_end = 10;t_span = [0 t_end];%% 2. Berechnung: Fall 1% Theta1 = 0, Theta2 = pi, dTheta1 = 0, dTheta2 = 1y0_case1 = [0; 0; pi; 1]; % Die Struktur-Ausgabe (sol) wird genutzt, da dies für Animationen vorteilhafter ist.options = odeset('RelTol', 1e-6, 'AbsTol', 1e-6);sol1 = ode45(@(t, y) pendulum_dynamics(t, y, p), t_span, y0_case1, options);%% 3. Berechnung: Fall 2% Theta1 = 0, Theta2 = pi, dTheta1 = 1, dTheta2 = 0y0_case2 = [0; 1; pi; 0]; sol2 = ode45(@(t, y) pendulum_dynamics(t, y, p), t_span, y0_case2, options);%% 4. Statische Visualisierung (Plots)figure('Name', 'Statische Analyse', 'Color', 'white', 'Position', [300, 100, 1000, 600]);% Die Daten für die Plots werden extrahiertt1 = sol1.x; y1 = sol1.y';t2 = sol2.x; y2 = sol2.y';% --- Plot für Fall 1 ---subplot(2, 2, 1);plot(t1, y1(:,1), 'LineWidth', 1.5, 'DisplayName', '\theta_1'); hold on;plot(t1, y1(:,3), 'LineWidth', 1.5, 'DisplayName', '\theta_2');title('Fall 1: Winkel über Zeit'); xlabel('s'); ylabel('rad'); legend; grid on;subplot(2, 2, 3);plot_static_trajectory(y1, p, 'Fall 1: Bahnkurve');% --- Plot für Fall 2 ---subplot(2, 2, 2);plot(t2, y2(:,1), 'LineWidth', 1.5, 'DisplayName', '\theta_1'); hold on;plot(t2, y2(:,3), 'LineWidth', 1.5, 'DisplayName', '\theta_2');title('Fall 2: Winkel über Zeit'); xlabel('s'); ylabel('rad'); legend; grid on;subplot(2, 2, 4);plot_static_trajectory(y2, p, 'Fall 2: Bahnkurve');%% 5. Animation (Vergleich)% Ein neues Fenster für die Live-Simulation wird erstelltfprintf('Starte Animation...\n');animate_comparison(sol1, sol2, p, t_end);%% --- Hilfsfunktionen ---function dydt = pendulum_dynamics(~, y, p)    theta1 = y(1); omega1 = y(2);    theta2 = y(3); omega2 = y(4);        delta = theta1 - theta2;    sin_d = sin(delta); cos_d = cos(delta);        % Die Matrix A wird aufgestellt    k1 = (p.m2 / (p.m1 + p.m2)) * (p.l2 / p.l1);    k2 = p.l1 / p.l2;    A = [1, k1 * cos_d; k2 * cos_d, 1];         % Der Vektor b wird aufgestellt    b1 = -k1 * omega2^2 * sin_d - (p.g / p.l1) * sin(theta1);    b2 = k2 * omega1^2 * sin_d - (p.g / p.l2) * sin(theta2);    b = [b1; b2];        alpha = A \ b;    dydt = [omega1; alpha(1); omega2; alpha(2)];endfunction plot_static_trajectory(y, p, title_str)    theta1 = y(:,1); theta2 = y(:,3);    x1 = p.l1 * sin(theta1); y1 = -p.l1 * cos(theta1);    x2 = x1 + p.l2 * sin(theta2); y2 = y1 - p.l2 * cos(theta2);        plot(x1, y1, 'Color', [0.8 0.8 0.8], 'LineStyle', '--'); hold on;    plot(x2, y2, 'b-');    plot(x2(1), y2(1), 'go', 'MarkerFaceColor', 'g'); % Start    plot(x2(end), y2(end), 'ro', 'MarkerFaceColor', 'r'); % Ende    title(title_str); xlabel('x'); ylabel('y'); axis equal; grid on;endfunction animate_comparison(sol1, sol2, p, t_end)    % Parameter für die Animation werden definiert    FPS = 60;    dt = 1/FPS;    t_anim = 0:dt:t_end;        % Die Lösungen werden auf feste Zeitschritte interpoliert (wichtig für ein flüssiges Bild)    y1_anim = deval(sol1, t_anim);    y2_anim = deval(sol2, t_anim);        % Die Grafik wird vorbereitet    f = figure('Name', 'Vergleich Animation', 'Color', 'w', 'Position', [300, 100, 1000, 600]);        % Linker Plot (Fall 1)    subplot(1, 2, 1); hold on; grid on; axis equal;    axis([-3.5 3.5 -3.5 3.5]); title('Fall 1');    pend1 = plot([0 0], [0 0], 'k-o', 'LineWidth', 2, 'MarkerFaceColor', 'k');    trace1 = plot(0, 0, 'b.', 'MarkerSize', 1); % Spur        % Rechter Plot (Fall 2)    subplot(1, 2, 2); hold on; grid on; axis equal;    axis([-3.5 3.5 -3.5 3.5]); title('Fall 2');    pend2 = plot([0 0], [0 0], 'k-o', 'LineWidth', 2, 'MarkerFaceColor', 'k');    trace2 = plot(0, 0, 'r.', 'MarkerSize', 1); % Spur        % Arrays für die Spur werden initialisiert    trace_x1 = []; trace_y1 = [];    trace_x2 = []; trace_y2 = [];        for i = 1:length(t_anim)        if ~isvalid(f), break; end % Falls das Fenster geschlossen wurde                % Die Koordinaten für Fall 1 werden berechnet        th1 = y1_anim(1, i); th2 = y1_anim(3, i);        x1_1 = p.l1*sin(th1); y1_1 = -p.l1*cos(th1);        x2_1 = x1_1 + p.l2*sin(th2); y2_1 = y1_1 - p.l2*cos(th2);                % Die Koordinaten für Fall 2 werden berechnet        th1_2 = y2_anim(1, i); th2_2 = y2_anim(3, i);        x1_2 = p.l1*sin(th1_2); y1_2 = -p.l1*cos(th1_2);        x2_2 = x1_2 + p.l2*sin(th2_2); y2_2 = y1_2 - p.l2*cos(th2_2);                % Die Grafiken werden aktualisiert        set(pend1, 'XData', [0, x1_1, x2_1], 'YData', [0, y1_1, y2_1]);        set(pend2, 'XData', [0, x1_2, x2_2], 'YData', [0, y1_2, y2_2]);                % Die Spur wird gezeichnet (jeden Frame)        trace_x1 = [trace_x1, x2_1]; trace_y1 = [trace_y1, y2_1];        trace_x2 = [trace_x2, x2_2]; trace_y2 = [trace_y2, y2_2];        set(trace1, 'XData', trace_x1, 'YData', trace_y1);        set(trace2, 'XData', trace_x2, 'YData', trace_y2);                drawnow limitrate;        % Optional: Pause für Echtzeit        pause(dt);     endend